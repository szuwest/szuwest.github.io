<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width" />

    <title>react-native框架源码学习(iOS)(下)</title>

    <link rel="stylesheet" href="https://szuwest.github.io/theme/css/normalize.css" />
    <link rel="stylesheet" href="https://szuwest.github.io/theme/css/foundation.min.css" />
    <link rel="stylesheet" href="https://szuwest.github.io/theme/css/style.css" />
    <link rel="stylesheet" href="https://szuwest.github.io/theme/css/pygments.css" />	
    <script src="https://szuwest.github.io/theme/js/custom.modernizr.js"></script>

    <!-- So Firefox can bookmark->"abo this site" -->

</head>

<body>

<!-- Nav Bar -->
<nav>
<div class="top-bar">
<div class="row">
    <div class="large-9 large-centered columns">
	    <h1><a href="https://szuwest.github.io">兄弟成长于天蓝时代</a></h1>
    </div>
</div>
</div>

<!-- Show menu items and pages -->
<div class="row">
<div class="large-9 columns">
    <ul class="button-group navigation">

    </ul>
</div>
</div>
</nav>
<!-- End Nav -->


<!-- Main Page Content and Sidebar -->
<div class="row">

    <!-- Main Blog Content -->
    <div class="large-9 columns">
<article>
    <header>
        <h3 class="article-title"><a href="https://szuwest.github.io/react-nativekuang-jia-yuan-ma-xue-xi-iosxia.html" rel="bookmark"
        title="Permalink to react-native框架源码学习(iOS)(下)">react-native框架源码学习(iOS)(下)</a></h3>
    </header>

<h6 class="subheader" title="2018-03-02T00:00:00">2018-03-02
</h6>


    <h1>react-native框架源码学习(iOS)(下)</h1>
<p>如果没有看过上篇，请先看<a href="">react-native框架源码学习(iOS)(上)</a>。</p>
<h3>JSCExecutor相关初始化</h3>
<p>在上篇中说到Instance的初始化方法initializeBridge里，最主要是创建了NativeToJsBridge的实例。而NativeToJsBridge的构造函数里，主要是调用了executorFactory来创建一个JSCExecutor。NativeToJsBridge的构造函数还包含更多的东西。</p>
<div class="highlight"><pre><span class="n">NativeToJsBridge</span><span class="o">::</span><span class="n">NativeToJsBridge</span><span class="p">(</span>
    <span class="n">JSExecutorFactory</span><span class="o">*</span> <span class="n">jsExecutorFactory</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ModuleRegistry</span><span class="o">&gt;</span> <span class="n">registry</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">MessageQueueThread</span><span class="o">&gt;</span> <span class="n">jsQueue</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">InstanceCallback</span><span class="o">&gt;</span> <span class="n">callback</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">m_destroyed</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">false</span><span class="p">))</span>
    <span class="p">,</span> <span class="n">m_delegate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">JsToNativeBridge</span><span class="o">&gt;</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span> <span class="n">callback</span><span class="p">))</span>
    <span class="p">,</span> <span class="n">m_executor</span><span class="p">(</span><span class="n">jsExecutorFactory</span><span class="o">-&gt;</span><span class="n">createJSExecutor</span><span class="p">(</span><span class="n">m_delegate</span><span class="p">,</span> <span class="n">jsQueue</span><span class="p">))</span>
    <span class="p">,</span> <span class="n">m_executorMessageQueueThread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">jsQueue</span><span class="p">))</span> <span class="p">{}</span>
</pre></div>


<p>NativeToJsBridge的成员变量包括了一个m_delegate(JsToNativeBridge)，一个m_executorMessageQueueThread（MessageQueueThread）和m_executor（JSCExecutor），在它的构造函数里，将JsToNativeBridge创建了然后又传给jsExecutorFactory来创建JSCExecutor，JsToNativeBridge实际上是给JSCExecutor使用的。</p>
<div class="highlight"><pre>JSCExecutor::JSCExecutor(std::shared_ptr<span class="nt">&lt;ExecutorDelegate&gt;</span> delegate,
                         std::shared_ptr<span class="nt">&lt;MessageQueueThread&gt;</span> messageQueueThread,
                         const folly::dynamic<span class="err">&amp;</span> jscConfig) throw(JSException) :
    m_delegate(delegate),
    m_messageQueueThread(messageQueueThread),
    m_nativeModules(delegate ? delegate-&gt;getModuleRegistry() : nullptr),
    m_jscConfig(jscConfig) {
  initOnJSVMThread();

  {
    SystraceSection s(&quot;nativeModuleProxy object&quot;);
    installGlobalProxy(m_context, &quot;nativeModuleProxy&quot;,
                       exceptionWrapMethod<span class="err">&lt;</span><span class="ni">&amp;JSCExecutor::getNativeModule&gt;());</span>
  }
}

void JSCExecutor::initOnJSVMThread() throw(JSException) {
    ......
    m_context = JSC_JSGlobalContextCreateInGroup(useCustomJSC, nullptr, globalClass);
    .....
    installNativeHook<span class="err">&lt;</span><span class="ni">&amp;JSCExecutor::nativeFlushQueueImmediate&gt;(&quot;nativeFlushQueueImmediate&quot;);</span>
  installNativeHook<span class="err">&lt;</span><span class="ni">&amp;JSCExecutor::nativeCallSyncHook&gt;(&quot;nativeCallSyncHook&quot;);</span>
  ......
}
</pre></div>


<p>在initOnJSVMThread中，先创建了全局的JSGlobalContext,然后给这个context注册了nativeFlushQueueImmediate和nativeCallSyncHook回调函数，这两个函数专门给JS调用。这两个函数都将会在MessageQueue.js中被调用。到这里终于有看到JS相关的调用，这里说明一下核心的JS源码存放目录。在工程目录/node_modules/react-native/Libraries/BatchedBridge目录下，主要有BatchedBridge.js,MessageQueue.js,NativeModules.js三个文件。</p>
<p>在创建context的时候，使用了宏，最终会调用JavaScriptCore的代码。这个全局的context很重要，OC中要运行js代码就是靠他。而js代码中的global对象对应就是OC中的这个context。而nativeFlushQueueImmediate这个方法主要是将js传过来的队列里面的需要调用的方法一起调用了。nativeCallSyncHook这个方式主要是给JS直接同步调用OC方法来用的。为什么这么做后面再说，我们现在只需知道在创建context之后，就已经将OC的这两个方法注入到js的global对象中。</p>
<p>initOnJSVMThread()执行之后，往m_context中注册了nativeModuleProxy的JS对象，将这个对象绑定到了getNativeModule这个函数。</p>
<div class="highlight"><pre>installGlobalProxy(m_context, &quot;nativeModuleProxy&quot;,
                       exceptionWrapMethod<span class="err">&lt;</span><span class="ni">&amp;JSCExecutor::getNativeModule&gt;());</span>
</pre></div>


<p>那么nativeModuleProxy在JS中到底是什么东西？这个定义在NativeModules.js中。</p>
<div class="highlight"><pre><span class="kd">let</span> <span class="nx">NativeModules</span> <span class="o">:</span> <span class="p">{[</span><span class="nx">moduleName</span><span class="o">:</span> <span class="nx">string</span><span class="p">]</span><span class="o">:</span> <span class="nb">Object</span><span class="p">}</span> <span class="o">=</span> <span class="p">{};</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">global</span><span class="p">.</span><span class="nx">nativeModuleProxy</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">NativeModules</span> <span class="o">=</span> <span class="nx">global</span><span class="p">.</span><span class="nx">nativeModuleProxy</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="err">·······</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">NativeModules</span><span class="p">;</span>
</pre></div>


<p>我们可以看到NativeModules就是指向了nativeModuleProxy，即就是OC的代理。我们要调用OC某个类的方法，就是通过NativeModules来调用的。例如我们已经定义好另一个对JS暴露的录音类AudioRecorder,那么在JS中要调用这个类的方法，就可以 let AudioRecorder = NativeModules.AudioRecorder; AudioRecorder.record();这样调用。那么我们知道它其实是调用到了OC的JSCExecutor中的getNativeModule方法，getNativeModule方法其实主要作用根据传入的模块名字生成对应的模块配置，具体实现后面再说。这里说一下JS代码里有个else分支，这是NativeModules生成的另一种做法：把所有的OC要暴露的类和方法都存在remoteModuleConfig里，然后他们注入到NativeModules里（在OC里对应的代码在RCTObjcExecutor的构造函数里）。</p>
<p>到这里JSCExecutor的初始化完成。我们重新回到RCTCxxBridge的start方法。跟JSCExecutor同时进行的是加载js源码，jsBundle的加载是通过RCTJavaScriptLoader进行的，这里不进行讨论。当初始化和js源码加载完成后，就会执行js源码。</p>
<h3>js源码执行</h3>
<p>在初始化过程中我们已经创建好全局的JavaScriptCore context，并在这个context中注入了nativeFlushQueueImmediate，nativeCallSyncHook，getNativeModule三个回调方法。现在将执行已加载的JS源码。它是执行链是这样的</p>
<ul>
<li>[RCTCxxBridge executeSourceCode: ]</li>
<li>[RCTCxxBridge enqueueApplicationScript:]</li>
<li>void Instance::loadScriptFromString()</li>
<li>void NativeToJsBridge::loadApplication()<ul>
<li>void JSCExecutor::loadApplicationScript()</li>
<li>void JSCExecutor::flush()</li>
<li>void JSCExecutor::bindBridge()</li>
</ul>
</li>
</ul>
<p>在 void JSCExecutor::loadApplicationScript方法最重要的代码如下</p>
<div class="highlight"><pre><span class="p">......</span>
<span class="n">evaluateScript</span><span class="p">(</span><span class="n">m_context</span><span class="p">,</span> <span class="n">jsScript</span><span class="p">,</span> <span class="n">jsSourceURL</span><span class="p">);</span>
<span class="p">.....</span>
<span class="n">flush</span><span class="p">();</span>
</pre></div>


<p>执行在context中执行JS源码，会初始化JS环境，BatchedBridge.js,NativeModules.js中的初始化代码也会执行。在BatchedBridge.js中，创建了一个名为BatchedBridge的MessageQueue，并设置到global的__fbBatchedBridge属性里，这个属性后面会用到。在初始化JS环境的时候，会加载到某些NativeModule，这些module才会被初始化，即调用到OC的getNativeModule方法。例如我打断点捕获到最开始初始化的一个NativeModule是PlatformConstants,它对应的OC类是RCTPlatform。当相关的Module都加载完之后，evaluateScript方法执行完，JS环境初始化完毕。然后就到执行flush方法。</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="n">JSCExecutor</span><span class="o">::</span><span class="n">flush</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">SystraceSection</span> <span class="n">s</span><span class="p">(</span><span class="s">&quot;JSCExecutor::flush&quot;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">m_flushedQueueJS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">callNativeModules</span><span class="p">(</span><span class="n">m_flushedQueueJS</span><span class="o">-&gt;</span><span class="n">callAsFunction</span><span class="p">({}));</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// When a native module is called from JS, BatchedBridge.enqueueNativeCall()</span>
  <span class="c1">// is invoked.  For that to work, require(&#39;BatchedBridge&#39;) has to be called,</span>
  <span class="c1">// and when that happens, __fbBatchedBridge is set as a side effect.</span>
  <span class="k">auto</span> <span class="n">global</span> <span class="o">=</span> <span class="n">Object</span><span class="o">::</span><span class="n">getGlobalObject</span><span class="p">(</span><span class="n">m_context</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">batchedBridgeValue</span> <span class="o">=</span> <span class="n">global</span><span class="p">.</span><span class="n">getProperty</span><span class="p">(</span><span class="s">&quot;__fbBatchedBridge&quot;</span><span class="p">);</span>
  <span class="c1">// So here, if __fbBatchedBridge doesn&#39;t exist, then we know no native calls</span>
  <span class="c1">// have happened, and we were able to determine this without forcing</span>
  <span class="c1">// BatchedBridge to be loaded as a side effect.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">batchedBridgeValue</span><span class="p">.</span><span class="n">isUndefined</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// If calls were made, we bind to the JS bridge methods, and use them to</span>
    <span class="c1">// get the pending queue of native calls.</span>
    <span class="n">bindBridge</span><span class="p">();</span>
    <span class="n">callNativeModules</span><span class="p">(</span><span class="n">m_flushedQueueJS</span><span class="o">-&gt;</span><span class="n">callAsFunction</span><span class="p">({}));</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m_delegate</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// If we have a delegate, we need to call it; we pass a null list to</span>
    <span class="c1">// callNativeModules, since we know there are no native calls, without</span>
    <span class="c1">// calling into JS again.  If no calls were made and there&#39;s no delegate,</span>
    <span class="c1">// nothing happens, which is correct.</span>
    <span class="n">callNativeModules</span><span class="p">(</span><span class="n">Value</span><span class="o">::</span><span class="n">makeNull</span><span class="p">(</span><span class="n">m_context</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>这是flush方法被第一次执行，所以m_flushedQueueJS为空，然后取到JS中的global对象中的__fbBatchedBridge对象。我们知道在JS初始化的时候，这个值已经被填上MessageQueue，所以这里会进入bindBridge()方法。</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="n">JSCExecutor</span><span class="o">::</span><span class="n">bindBridge</span><span class="p">()</span> <span class="n">throw</span><span class="p">(</span><span class="n">JSException</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SystraceSection</span> <span class="n">s</span><span class="p">(</span><span class="s">&quot;JSCExecutor::bindBridge&quot;</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">call_once</span><span class="p">(</span><span class="n">m_bindFlag</span><span class="p">,</span> <span class="p">[</span><span class="n">this</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">global</span> <span class="o">=</span> <span class="n">Object</span><span class="o">::</span><span class="n">getGlobalObject</span><span class="p">(</span><span class="n">m_context</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">batchedBridgeValue</span> <span class="o">=</span> <span class="n">global</span><span class="p">.</span><span class="n">getProperty</span><span class="p">(</span><span class="s">&quot;__fbBatchedBridge&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">batchedBridgeValue</span><span class="p">.</span><span class="n">isUndefined</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">requireBatchedBridge</span> <span class="o">=</span> <span class="n">global</span><span class="p">.</span><span class="n">getProperty</span><span class="p">(</span><span class="s">&quot;__fbRequireBatchedBridge&quot;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">requireBatchedBridge</span><span class="p">.</span><span class="n">isUndefined</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">batchedBridgeValue</span> <span class="o">=</span> <span class="n">requireBatchedBridge</span><span class="p">.</span><span class="n">asObject</span><span class="p">().</span><span class="n">callAsFunction</span><span class="p">({});</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">batchedBridgeValue</span><span class="p">.</span><span class="n">isUndefined</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">throw</span> <span class="n">JSException</span><span class="p">(</span><span class="s">&quot;Could not get BatchedBridge, make sure your bundle is packaged correctly&quot;</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">batchedBridge</span> <span class="o">=</span> <span class="n">batchedBridgeValue</span><span class="p">.</span><span class="n">asObject</span><span class="p">();</span>
    <span class="n">m_callFunctionReturnFlushedQueueJS</span> <span class="o">=</span> <span class="n">batchedBridge</span><span class="p">.</span><span class="n">getProperty</span><span class="p">(</span><span class="s">&quot;callFunctionReturnFlushedQueue&quot;</span><span class="p">).</span><span class="n">asObject</span><span class="p">();</span>
    <span class="n">m_invokeCallbackAndReturnFlushedQueueJS</span> <span class="o">=</span> <span class="n">batchedBridge</span><span class="p">.</span><span class="n">getProperty</span><span class="p">(</span><span class="s">&quot;invokeCallbackAndReturnFlushedQueue&quot;</span><span class="p">).</span><span class="n">asObject</span><span class="p">();</span>
    <span class="n">m_flushedQueueJS</span> <span class="o">=</span> <span class="n">batchedBridge</span><span class="p">.</span><span class="n">getProperty</span><span class="p">(</span><span class="s">&quot;flushedQueue&quot;</span><span class="p">).</span><span class="n">asObject</span><span class="p">();</span>
    <span class="n">m_callFunctionReturnResultAndFlushedQueueJS</span> <span class="o">=</span> <span class="n">batchedBridge</span><span class="p">.</span><span class="n">getProperty</span><span class="p">(</span><span class="s">&quot;callFunctionReturnResultAndFlushedQueue&quot;</span><span class="p">).</span><span class="n">asObject</span><span class="p">();</span>
  <span class="p">});</span>
<span class="p">}</span>
</pre></div>


<p>从代码可以看出，它从__fbBatchedBridge（也即是MessageQueue）中将几个函数转成了OC对象，这个几个方法将在后面在需要的时候调用。这几个方法都定义在MessageQueue.js中。MessageQueue这个JS类很重要，代码也比较多，这里就不贴了。callFunctionReturnFlushedQueue这个函数主要就是执行传入JS中的模块和方法，并把JS中的queue返回。这个queue存储了JS要调用的OC模块的类和方法和相关参数。OC中获取到这个queue后，就会解析这个queue中的内容，得到相关模块的配置和参数，并进行动态调用。m_flushedQueueJS这个对象对应的JS函数是flushedQueue，这个函数就是将queue返回，然后清空。在bindBridge()执行完之后，立马执行了callNativeModules(m_flushedQueueJS-&gt;callAsFunction({}))。这里就是将js中的queue拿过来进行调用。</p>
<p>为了更好的理解OC与JS是如何相互调用的，还是要先说说是怎么生成模块配置的。JS如何调用到OC。</p>
<h3>JS调用OC</h3>
<p>当JS要加载某个module的之后，会调用到JSCExecutor中的getNativeModule方法，然后它会找该module，如果第一次加载该module，就会去创建该module的配置，然后存起来，下次再取时就直接返回已将建好的。下面是涉及的方法调用。</p>
<ul>
<li>JSCExecutor::getNativeModule()</li>
<li>JSCNativeModules::getModule()</li>
<li>JSCNativeModules::createModule()<ul>
<li>ModuleRegistry::getConfig()<ul>
<li>RCTNativeModule::getMethods()<ul>
<li>[RCTModuleData methods]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这里看一下关键方法JSCNativeModules::createModule方法</p>
<div class="highlight"><pre><span class="nx">folly</span><span class="p">::</span><span class="nl">Optional</span><span class="o">&lt;</span><span class="nb">Object</span><span class="o">&gt;</span> <span class="nx">JSCNativeModules</span><span class="p">::</span><span class="nl">createModule</span><span class="p">(</span><span class="nx">const</span> <span class="nx">std</span><span class="p">::</span><span class="nl">string</span><span class="o">&amp;</span> <span class="nb">name</span><span class="p">,</span> <span class="nx">JSContextRef</span> <span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">ReactMarker</span><span class="p">::</span><span class="nl">logTaggedMarker</span><span class="p">(</span><span class="nx">ReactMarker</span><span class="p">::</span><span class="nl">NATIVE_MODULE_SETUP_START</span><span class="p">,</span> <span class="nx">name.c_str</span><span class="p">());</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">m_genNativeModuleJS</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">auto</span> <span class="bp">global</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">::</span><span class="nl">getGlobalObject</span><span class="p">(</span><span class="nx">context</span><span class="p">);</span>
    <span class="n">m_genNativeModuleJS</span> <span class="o">=</span> <span class="bp">global.</span><span class="nb">getProperty</span><span class="p">(</span><span class="s2">&quot;__fbGenNativeModule&quot;</span><span class="p">)</span><span class="bp">.</span><span class="nx">asObject</span><span class="p">();</span>
    <span class="nx">m_genNativeModuleJS</span><span class="o">-&gt;</span><span class="nx">makeProtected</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="nx">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nx">m_moduleRegistry</span><span class="o">-&gt;</span><span class="nx">getConfig</span><span class="p">(</span><span class="nb">name</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">result.hasValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nb">Value</span> <span class="n">moduleInfo</span> <span class="o">=</span> <span class="nx">m_genNativeModuleJS</span><span class="o">-&gt;</span><span class="nx">callAsFunction</span><span class="p">({</span>
    <span class="nb">Value</span><span class="p">::</span><span class="nl">fromDynamic</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nb">result</span><span class="o">-&gt;</span><span class="nx">config</span><span class="p">),</span>
    <span class="nb">Value</span><span class="p">::</span><span class="nl">makeNumber</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nb">result</span><span class="o">-&gt;</span><span class="nb">index</span><span class="p">)</span>
  <span class="p">});</span>
  <span class="nx">CHECK</span><span class="p">(</span><span class="o">!</span><span class="nx">moduleInfo.isNull</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;Module returned from genNativeModule is null&quot;</span><span class="p">;</span>

  <span class="nx">folly</span><span class="p">::</span><span class="nl">Optional</span><span class="o">&lt;</span><span class="nb">Object</span><span class="o">&gt;</span> <span class="nx">module</span><span class="p">(</span><span class="nx">moduleInfo.asObject</span><span class="p">()</span><span class="bp">.</span><span class="nb">getProperty</span><span class="p">(</span><span class="s2">&quot;module&quot;</span><span class="p">)</span><span class="bp">.</span><span class="nx">asObject</span><span class="p">());</span>

  <span class="nx">ReactMarker</span><span class="p">::</span><span class="nl">logTaggedMarker</span><span class="p">(</span><span class="nx">ReactMarker</span><span class="p">::</span><span class="nl">NATIVE_MODULE_SETUP_STOP</span><span class="p">,</span> <span class="nx">name.c_str</span><span class="p">());</span>

  <span class="k">return</span> <span class="nx">module</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这可以看到取了JS中global对象的__fbGenNativeModule属性，存到了m_genNativeModuleJS。而__fbGenNativeModule定义在NativeModules.js中，它对应的是genModule函数。OC中将调用这个函数，把OC的Module生成JS的module，返回给JS，并最终OC中也会把它存在m_objects（map）中。genModule函数需要一个config参数，这个config主要是由m_moduleRegistry-&gt;getConfig生成。这个config里只要包含了像JS暴露的constants,methods。我们这里主要看看它是怎么收集到我们要暴露的方法的。</p>
<p>关键代码在[RCTModuleData methods]中</p>
<div class="highlight"><pre><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span><span class="o">&lt;</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">RCTBridgeMethod</span><span class="o">&gt;&gt;</span> <span class="o">*</span><span class="p">)</span><span class="nf">methods</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_methods</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSMutableArray</span><span class="o">&lt;</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">RCTBridgeMethod</span><span class="o">&gt;&gt;</span> <span class="o">*</span><span class="n">moduleMethods</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">new</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">([</span><span class="n">_moduleClass</span> <span class="n">instancesRespondToSelector</span><span class="o">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">methodsToExport</span><span class="p">)])</span> <span class="p">{</span>
      <span class="p">[</span><span class="n">moduleMethods</span> <span class="n">addObjectsFromArray</span><span class="o">:</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">instance</span> <span class="n">methodsToExport</span><span class="p">]];</span>
    <span class="p">}</span>

    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">methodCount</span><span class="p">;</span>
    <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">_moduleClass</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cls</span> <span class="o">&amp;&amp;</span> <span class="n">cls</span> <span class="o">!=</span> <span class="p">[</span><span class="n">NSObject</span> <span class="n">class</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">cls</span> <span class="o">!=</span> <span class="p">[</span><span class="n">NSProxy</span> <span class="n">class</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">Method</span> <span class="o">*</span><span class="n">methods</span> <span class="o">=</span> <span class="n">class_copyMethodList</span><span class="p">(</span><span class="n">object_getClass</span><span class="p">(</span><span class="n">cls</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">methodCount</span><span class="p">);</span><span class="c1">//注意这里取的是类方法</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">methodCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="n">methods</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">SEL</span> <span class="n">selector</span> <span class="o">=</span> <span class="n">method_getName</span><span class="p">(</span><span class="n">method</span><span class="p">);</span>
        <span class="c1">//主要这个前缀__rct_export__</span>
        <span class="k">if</span> <span class="p">([</span><span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span> <span class="n">hasPrefix</span><span class="o">:</span><span class="s">@&quot;__rct_export__&quot;</span><span class="p">])</span> <span class="p">{</span>
          <span class="kt">IMP</span> <span class="n">imp</span> <span class="o">=</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">method</span><span class="p">);</span>
          <span class="k">auto</span> <span class="n">exportedMethod</span> <span class="o">=</span> <span class="p">((</span><span class="k">const</span> <span class="n">RCTMethodInfo</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))</span><span class="n">imp</span><span class="p">)(</span><span class="n">_moduleClass</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>
          <span class="kt">id</span><span class="o">&lt;</span><span class="n">RCTBridgeMethod</span><span class="o">&gt;</span> <span class="n">moduleMethod</span> <span class="o">=</span> <span class="p">[[</span><span class="n">RCTModuleMethod</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithExportedMethod</span><span class="o">:</span><span class="n">exportedMethod</span>
                                                                                 <span class="nl">moduleClass:</span><span class="n">_moduleClass</span><span class="p">];</span>
          <span class="p">[</span><span class="n">moduleMethods</span> <span class="n">addObject</span><span class="o">:</span><span class="n">moduleMethod</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="n">free</span><span class="p">(</span><span class="n">methods</span><span class="p">);</span>
      <span class="n">cls</span> <span class="o">=</span> <span class="n">class_getSuperclass</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">_methods</span> <span class="o">=</span> <span class="p">[</span><span class="n">moduleMethods</span> <span class="n">copy</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">_methods</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里代码主要意思是先拿到所有类方法（或者叫静态方法），然后如果是特定前缀__rct_export__的方法，则是我们之前通过宏RCT_REMAP_METHOD（RCT_EXPORT_METHOD）定义生成的方法，然后获取这个方法的实现，并执行得到结果RCTMethodInfo。这个RCTMethodInfo里包含真正我们要暴露给JS调用的方法，用它来创建一个RCTModuleMethod。将所有需要的方法都生成之后，就保存了起来。这里RN的开发者很巧妙生成了一个静态方法，通过这个方法将真正需要的方法信息生成。为什么将这个特定方法定义为静态方法呢，我估计是静态方法比较少，查找的时候比查找实例方法快。</p>
<p>当配置信息都生成好之后，调用genModule方法生成JS的module。这里要特别说明一下genModule这个方法会调用到genMethod函数，genMethod函数会生成另外一个函数，而生成函数里，将module的方法调用放到了MessageQueue的队列中，等待OC被调用。这里特别说明一下在JS的代码中，传递的参数都是moduleId, methodId是数字类型，moduleId它代表的是该module在OC的modules数组中的下标，methodId代表的是该method在methodNames数组里的下标。相关函数都是挺复杂的，理解起来有点绕，可以多看看genModule和genMethod函数的实现。</p>
<p>所以，假设我们已有一个注册模块AudioRecord和暴露方法record.</p>
<div class="highlight"><pre> <span class="n">let</span> <span class="n">AudioRecorder</span> <span class="o">=</span> <span class="n">NativeModules</span><span class="p">.</span><span class="n">AudioRecorder</span><span class="p">;</span> 
 <span class="n">AudioRecorder</span><span class="p">.</span><span class="n">record</span><span class="p">();</span>
</pre></div>


<p>两句代码会发生：去OC中getNativeModule(AudioRecorder)寻找JS的module，现在m_objects字段中查找，如果没有找到则会走创建流程，先到m_moduleRegistry生成改类的配置信息，然后将配置信息传给JS的genModule函数生成名为AudioRecorder的js对象，调用genMethod生成名为record对应的JS函数，赋值给AudioRecorder对象,并保存在OC的一个字典（m_objects）中和返回这个JS对象。在JS中拿到这个对象后调用record函数，在record函数里，BatchedBridge.enqueueNativeCall就会被调用，moduleID，moduleID等信息就传入MessageQueue。我们看看enqueueNativeCall函数实现。</p>
<div class="highlight"><pre><span class="nx">enqueueNativeCall</span><span class="p">(</span>
    <span class="nx">moduleID</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span>
    <span class="nx">methodID</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span>
    <span class="k">params</span><span class="p">:</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="nb">any</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="nx">onFail</span><span class="p">:</span> <span class="o">?</span><span class="nx">Function</span><span class="p">,</span>
    <span class="nx">onSucc</span><span class="p">:</span> <span class="o">?</span><span class="nx">Function</span><span class="p">,</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">onFail</span> <span class="o">||</span> <span class="nx">onSucc</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">......</span>
      <span class="c1">// Encode callIDs into pairs of callback identifiers by shifting left and using the rightmost bit</span>
      <span class="c1">// to indicate fail (0) or success (1)</span>
      <span class="nx">onFail</span> <span class="o">&amp;&amp;</span> <span class="k">params</span><span class="bp">.</span><span class="nb">push</span><span class="p">(</span><span class="nx">this._callID</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
      <span class="nx">onSucc</span> <span class="o">&amp;&amp;</span> <span class="k">params</span><span class="bp">.</span><span class="nb">push</span><span class="p">((</span><span class="nx">this._callID</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">);</span>
      <span class="nx">this._successCallbacks</span><span class="err">[</span><span class="nx">this._callID</span><span class="cp">]</span> = onSucc;
      this._failureCallbacks<span class="cp">[</span><span class="nx">this._callID</span><span class="cp">]</span> = onFail;
    }

    ......
    this._callID++;

    this._queue<span class="cp">[</span><span class="nx">MODULE_IDS</span><span class="cp">]</span>.push(moduleID);
    this._queue<span class="cp">[</span><span class="nx">METHOD_IDS</span><span class="cp">]</span>.push(methodID);

    ......
    this._queue<span class="cp">[</span><span class="k">PARAMS</span><span class="cp">]</span>.push(params);

    const now = new Date().getTime();
    if (
      global.nativeFlushQueueImmediate <span class="err">&amp;&amp;</span>
      (now - this._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS ||
        this._inCall === 0)
    ) {
      var queue = this._queue;
      this._queue = <span class="cp">[</span><span class="err">[</span><span class="cp">]</span>, <span class="cp">[]</span>, <span class="cp">[]</span>, this._callID];
      this._lastFlush = now;
      global.nativeFlushQueueImmediate(queue);
    }
    Systrace.counterEvent(&#39;pending_js_to_native_queue&#39;, this._queue<span class="cp">[</span><span class="mi">0</span><span class="cp">]</span>.length);
    //
    if (this.__spy) {
      this.__spyNativeCall(moduleID, methodID, params, {
        failCbId: onFail ? params<span class="cp">[</span><span class="k">params</span><span class="bp">.</span><span class="nb">length</span> <span class="o">-</span> <span class="mi">2</span><span class="cp">]</span> : -1,
        successCbId: onSucc ? params<span class="cp">[</span><span class="k">params</span><span class="bp">.</span><span class="nb">length</span> <span class="o">-</span> <span class="mi">1</span><span class="cp">]</span> : -1,
      });
    }
  }
</pre></div>


<p>JS所有异步调用OC方法都会走到这里（同步方法走的是callSyncHook），我们可以看到先把回调存到数组里，然后把要调用的模块类，方法和参数都存在了queue中，当然还有回调函数对应的_callID（这里很巧妙地用一个数字代表了两个回调函数）。这里还有个判断，如果距离上次OC主动来调用JS超过了5毫秒，就会主动调用OC一开始就注入的nativeFlushQueueImmediate回调函数。在nativeFlushQueueImmediate这个方法里，OC会把传过来的queue里面需要调用的方法全部调用。</p>
<ul>
<li>JSCExecutor::nativeFlushQueueImmediate</li>
<li>JSCExecutor::flushQueueImmediate</li>
<li>JsToNativeBridge::callNativeModules<ul>
<li>ModuleRegistry::callNativeMethod<ul>
<li>RCTNativeModule::invoke<ul>
<li>RCTNativeModule::invokeInne<ul>
<li>[RCTModuleMethod invokeWithBridge:module:arguments:]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这里调用链条也很长，我们知道最终会到RCTModuleMethod类中，它是通过NSInvocation来实现动态调用的。</p>
<p>没有超过5毫秒的话，JS不主动调用OC的module，那OC到底什么时候会主动调用JS？</p>
<h3>OC调用JS</h3>
<p>在RCTCxxBridge中的start方法里，执行完JS源码后，会发送一个通知。在RCTRootView中监听了这个通知，执行了runApplication方法，这个方法里主动调用了JS。</p>
<div class="highlight"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">runApplication:</span><span class="p">(</span><span class="n">RCTBridge</span> <span class="o">*</span><span class="p">)</span><span class="nv">bridge</span>
<span class="p">{</span>
  <span class="n">NSString</span> <span class="o">*</span><span class="n">moduleName</span> <span class="o">=</span> <span class="n">_moduleName</span> <span class="o">?:</span> <span class="s">@&quot;&quot;</span><span class="p">;</span>
  <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">appParameters</span> <span class="o">=</span> <span class="err">@</span><span class="p">{</span>
    <span class="s">@&quot;rootTag&quot;</span><span class="o">:</span> <span class="n">_contentView</span><span class="p">.</span><span class="n">reactTag</span><span class="p">,</span>
    <span class="s">@&quot;initialProps&quot;</span><span class="o">:</span> <span class="n">_appProperties</span> <span class="o">?:</span> <span class="err">@</span><span class="p">{},</span>
  <span class="p">};</span>

  <span class="n">RCTLogInfo</span><span class="p">(</span><span class="s">@&quot;Running application %@ (%@)&quot;</span><span class="p">,</span> <span class="n">moduleName</span><span class="p">,</span> <span class="n">appParameters</span><span class="p">);</span>
  <span class="p">[</span><span class="n">bridge</span> <span class="n">enqueueJSCall</span><span class="o">:</span><span class="s">@&quot;AppRegistry&quot;</span>
                 <span class="nl">method:</span><span class="s">@&quot;runApplication&quot;</span>
                   <span class="nl">args:</span><span class="err">@</span><span class="p">[</span><span class="n">moduleName</span><span class="p">,</span> <span class="n">appParameters</span><span class="p">]</span>
             <span class="nl">completion:</span><span class="nb">NULL</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>


<p>这里是JS的程序入口，之后会创建视图之类的。我们看看OC是怎么调用JS的。</p>
<ul>
<li>RCTBridge:: enqueueJSCall()</li>
<li>RCTCxxBridge:: enqueueJSCall()<ul>
<li>Instance::callJSFunction()<ul>
<li>NativeToJsBridge::callFunction()<ul>
<li>JSCExecutor::callFunction()</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我们看看JSCExecutor是如何调用JS的。</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="n">JSCExecutor</span><span class="o">::</span><span class="n">callFunction</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">moduleId</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">methodId</span><span class="p">,</span> <span class="k">const</span> <span class="n">folly</span><span class="o">::</span><span class="n">dynamic</span><span class="o">&amp;</span> <span class="n">arguments</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SystraceSection</span> <span class="n">s</span><span class="p">(</span><span class="s">&quot;JSCExecutor::callFunction&quot;</span><span class="p">);</span>
  <span class="c1">// This weird pattern is because Value is not default constructible.</span>
  <span class="c1">// The lambda is inlined, so there&#39;s no overhead.</span>
  <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">JSContextLock</span> <span class="n">lock</span><span class="p">(</span><span class="n">m_context</span><span class="p">);</span>
    <span class="n">try</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">m_callFunctionReturnResultAndFlushedQueueJS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bindBridge</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">m_callFunctionReturnFlushedQueueJS</span><span class="o">-&gt;</span><span class="n">callAsFunction</span><span class="p">({</span>
        <span class="n">Value</span><span class="p">(</span><span class="n">m_context</span><span class="p">,</span> <span class="n">String</span><span class="o">::</span><span class="n">createExpectingAscii</span><span class="p">(</span><span class="n">m_context</span><span class="p">,</span> <span class="n">moduleId</span><span class="p">)),</span>
        <span class="n">Value</span><span class="p">(</span><span class="n">m_context</span><span class="p">,</span> <span class="n">String</span><span class="o">::</span><span class="n">createExpectingAscii</span><span class="p">(</span><span class="n">m_context</span><span class="p">,</span> <span class="n">methodId</span><span class="p">)),</span>
        <span class="n">Value</span><span class="o">::</span><span class="n">fromDynamic</span><span class="p">(</span><span class="n">m_context</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">arguments</span><span class="p">))</span>
      <span class="p">});</span>
    <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">throw_with_nested</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Error calling &quot;</span> <span class="o">+</span> <span class="n">moduleId</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">methodId</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}();</span>
  <span class="n">callNativeModules</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">result</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<p>OC调用JS是通过bindBridge()里取到的JS定义的函数callFunctionReturnFlushedQueue来调用的。这函数需要的参数就是moduleName,methodName和method调用需要的参数。JS中拿到这些参数会在_lazyCallableModules里找到对应的JS module来进行对应的方法调用。_lazyCallableModules存的是需要给OC调用的JS module。AppRegistry模块在执行JS源码的之后就注册到这个_lazyCallableModules里。callFunctionReturnFlushedQueue函数不但执行了OC要调用的JS模块，最后还把queue传回到了OC，我们知道这个queue里存的都是JS要调用的OC模块信息，所以OC拿到这个queue之后就执行了调用callNativeModules。RN的机制就是OC在调用JS模块之后，也把JS中待调用的OC模块一起执行了。</p>
<p>还有什么情况，OC会主动调用JS呢。通过在xcode中搜索enqueueJSCall方法的调用，可以看到主要是在RCTEventDispatcher，RCTEventEmitter和RCTTiming。从此可以知道主要是跟事件触发和定时器相关。这也很合理，因为在移动操作系统是基于事件触发机制。大部分事件都是空转，只有事件触发后才会进行相关调用。</p>
<h2>总结</h2>
<p>大致总结一下RN APP的启动流程：在APPDelegate的启动方法中创建了一个RCTRootView，然后在RCTRootView中创建了RCTBridge，RCTBridge中创建了RCTCxxBridge，并调用了start方法。在start方法里先创建了一个专门用来运行JS代码的Thread，这个Thread绑定到了一个runloop。然后将所有注册的module生成RCTModuleData，并根据需要调用他们的初始化方法。然后一边在JS线程中执行Intance的初始化方法，一边异步进行js源码的加载。在Intance的初始化方法里最终会创建一个JSCExecutor,在JSCExecutor里创建了一个全局的js context,并注入了几个OC的回调方法，包括NativeModuleProxy对应的getNativeModule方法。当JS源码都加载完，其他初始化也完成，就会在JS context中执行JS源码，建立JS环境和JS的初始化。这时候一些被JS调用到的OC module就会初始化，会调用之前注入JS中的getNativeModule方法，这个方法会把module的配置信息生成，并交给JS的genModule方法来生成JS的对象，并在OC中存起来。JS源码执行完之后，OC会调用flush方法，然后会调用到bindBridge方法，将MessageQueue.js中定义的几个方法存在OC中以备调用。然后将MessageQueue存储的OC待调用方法进行调用。到这里，JS源码执行完毕，会发一个通知，RCTRootView会收到这个通知，然后就调用了js中的AppRegistry的runApplication方法，到这里，JS的入口就被调用，界面就会渲染出来。</p>
<p>总结起来，JS和OC的相互通信是经过JavaScriptCore机制来进行的。OC将要暴露给JS的放类和方法生成配置信息，然后交个JS生成JS对象和方法，但是JS中对应的对象和方法并不是直接调用OC的方法，而且先放入一个队列中，交由OC来调用。OC拿到对应的配置信息然后进行动态调用。OC调用JS的对象和方法，是直接调用，JS中存储了要暴露的对象module.</p>
<h2>参考资料</h2>
<p><a href="http://www.cocoachina.com/ios/20170720/19958.html">深入浅出 JavaScriptCore</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1004875">JavaScriptCore全面解析 （上篇）</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1004876">JavaScriptCore全面解析 （下篇）
</a></p>
<p><a href="https://www.jianshu.com/p/931367388a8d?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">理解React-Native(0.46) 中native和js通信原理(iOS)</a></p>
<p><a href="http://blog.cnbang.net/tech/2698/">React Native通信机制详解</a></p>
<p>如果你觉得这篇文章有用，请打赏小钱喝杯咖啡^_^
<img alt="打赏" src="https://raw.githubusercontent.com/szuwest/szuwest.github.io/master/images/2018-02-21%20133111.jpg" /></p>
<p class="subheader">Category: <a href="https://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="https://szuwest.github.io/tag/reactnative-yuan-ma-ios.html">ReactNative 源码 iOS </a>
</p>




	<h4>Comments</h4>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'westblog'
        var disqus_identifier = "react-nativekuang-jia-yuan-ma-xue-xi-iosxia.html";
        var disqus_url = "https://szuwest.github.io/react-nativekuang-jia-yuan-ma-xue-xi-iosxia.html";

        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</article>
    </div>
    <!-- End Main Content -->

    <!-- Sidebar -->
    <aside class="large-3 columns">
        <h5 class="sidebar-title">Site</h5>
        <ul class="side-nav">
            <li><a href="https://szuwest.github.io/archives.html">Archives</a>
            <li><a href="https://szuwest.github.io/tags.html">Tags</a>


        </ul>

		
        <h5 class="sidebar-title">Categories</h5>
        <ul class="side-nav">
            <li><a href="https://szuwest.github.io/category/android.html">Android</a></li>
            <li><a href="https://szuwest.github.io/category/bian-cheng-jia-gou.html">编程架构</a></li>
            <li><a href="https://szuwest.github.io/category/chan-pin.html">产品</a></li>
            <li><a href="https://szuwest.github.io/category/ios.html">iOS</a></li>
            <li><a href="https://szuwest.github.io/category/ji-zhu.html">技术</a></li>
            <li><a href="https://szuwest.github.io/category/sheng-huo.html">生活</a></li>
            <li><a href="https://szuwest.github.io/category/suan-fa.html">算法</a></li>
            <li><a href="https://szuwest.github.io/category/zong-jie.html">总结</a></li>
   
        </ul>

        <h5 class="sidebar-title">Links</h5>
        <ul class="side-nav">
            <li><a href="https://szuwest.github.io/pages/about.html">About</a></li>
            <li><a href="https://szuwest.github.io/feeds/all.atom.xml">RSS</a></li>
        </ul>
		
        <h5 class="sidebar-title">Social</h5>
        <ul class="side-nav">
            <li><a href="https://github.com/szuwest">Github</a></li>
            <li><a href="https://www.facebook.com/profile.php?id=1084651913">Facebook</a></li>
            <li><a href="http://weibo.com/szuwest">微博</a></li>
        </ul>

    </aside> <!-- End Sidebar -->

</div> <!-- End Main Content and Sidebar -->


<!-- Footer -->
<footer class="row">
    <div class="large-12 columns">
        <hr />
        <div class="row">
            <div class="large-6 columns">
                <p>兄弟成长于天蓝时代 by West</p>
            </div>
            </div>
    </div>
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-55687145-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
</footer>