<!DOCTYPE html>
<head>
    <meta charset="utf-8" />
    <!-- Set the viewport width to device width for mobile -->
    <meta name="viewport" content="width=device-width" />

    <title>West's blog - 技术</title>

    <link rel="stylesheet" href="https://szuwest.github.io/theme/css/normalize.css" />
    <link rel="stylesheet" href="https://szuwest.github.io/theme/css/foundation.min.css" />
    <link rel="stylesheet" href="https://szuwest.github.io/theme/css/style.css" />
    <link rel="stylesheet" href="https://szuwest.github.io/theme/css/pygments.css" />	
    <script src="https://szuwest.github.io/theme/js/custom.modernizr.js"></script>

    <!-- So Firefox can bookmark->"abo this site" -->

</head>

<body>

<!-- Nav Bar -->
<nav>
<div class="top-bar">
<div class="row">
    <div class="large-9 large-centered columns">
	    <h1><a href="https://szuwest.github.io">West's blog</a></h1>
    </div>
</div>
</div>

<!-- Show menu items and pages -->
<div class="row">
<div class="large-9 columns">
    <ul class="button-group navigation">

    </ul>
</div>
</div>
</nav>
<!-- End Nav -->


<!-- Main Page Content and Sidebar -->
<div class="row">

    <!-- Main Blog Content -->
    <div class="large-9 columns">
        
        

            <article>
                <a href="https://szuwest.github.io/flutter-appjia-ru-xin-ge-tui-song-tong-zhi-fang-an.html"><h3 class="article-title">Flutter APP加入信鸽推送通知方案</h3></a>
<h6 class="subheader" title="2021-02-03T00:00:00">2021-02-03
</h6>


<h1>Flutter APP加入信鸽推送通知方案</h1>
<p>最近我们团队又采用Flutter开发一款新APP。而且最近由于信鸽（现在又叫腾讯云移动推送）修改按量收费，我们决定在新APP里加入信鸽SDK来做推送通知功能。</p>
<p>我们之前主要主APP里已经使用了信鸽SDK来做推送通知功能，但这次是第一次在Flutter开发的APP上加入推送通知功能。当我们完全加入该功能之后，我觉得可以将这个技术方案分享一下。</p>
<p>其实加入信鸽SDK的方式跟原生APP是一样的，只是在处理推送通知页面跳转方式不一样而已。</p>
<p>先说说信鸽SDK的优势和注意事项。信鸽SDK以前是免费的，在去年才改成收费的，并入了腾讯云。所以他们才改名叫腾讯云移动推送。信鸽SDK还算比较稳定，毕竟是大厂开发的。收费后新增了很多统计功能，有一个重要的数据是通知开启率，还有就是通知点击率，还是很有用的数据。改成收费的的新版SDK有个问题，会跟我们的采用的iOS版的growingIO统计SDK冲突，导致growingIO活跃用户丢失。最后跟growingIO开发人员反馈后，修改growingIO SDK采用的统计方式才正常。</p>
<p>安卓版的信鸽SDK集成了几大厂商的通道，比较容易集成到自己项目里，这也是他的优势。然后为了推送通知能尽量在两端保持一致，这里要专门提一下推送配置。</p>
<h2>推送配置</h2>
<p>我觉得这一点对于推送通知很重要，尽量将两端的配置保持一致，服务器或者运营编辑在推送一条消息的时候，可以较简单的完成，不容易出错。在安卓端，我们采用客户端自定义方式，即自定义intent-filter里的data字段里的scheme，host，path字段。这里scheme，host一般是固定的，每个页面的path不同。而iOS里采用开启附加参数方式。附加参数里有个必须字段就是path字段。这里两端的path字段就是一致，而且还可以根据页面情况增加其他参数。</p>
<p>AndroidManifest.xml配置</p>
<div class="highlight"><pre><span></span><span class="nt">&lt;activity</span> <span class="na">android:name=</span><span class="s">&quot;.MainActivity&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;intent-filter&gt;</span>
        <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">&quot;android.intent.action.VIEW&quot;</span> <span class="nt">/&gt;</span>
       <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">&quot;android.intent.category.DEFAULT&quot;</span> <span class="nt">/&gt;</span>
       <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">&quot;android.intent.category.BROWSABLE&quot;</span> <span class="nt">/&gt;</span>
         <span class="nt">&lt;data</span>
             <span class="na">android:host=</span><span class="s">&quot;myhost&quot;</span>
             <span class="na">android:path=</span><span class="s">&quot;/main&quot;</span>
             <span class="na">android:scheme=</span><span class="s">&quot;myscheme&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/intent-filter&gt;</span>
<span class="nt">&lt;/activity&gt;</span>
</pre></div>


<p>信鸽里的推送配置（采用客户端自定义方式）,还可以往页面传递参数param1</p>
<div class="highlight"><pre><span></span>myscheme://myhost/main?param1=xx
</pre></div>


<p>信鸽里的iOS配置，开启高级配置里的<strong>附加参数</strong></p>
<div class="highlight"><pre><span></span>path=main
param1=xxx
</pre></div>


<p>服务器API推送也是按照类似的方式配置参数，跟服务器开发人员约定好了就行了。</p>
<p>采用这种方式，可以专门写个文档，将每个要推送的页面对应的path,需要的额外参数都定义好，服务器开发人员或者运营编辑都可以查阅这个文档来创建推送。非常方便。</p>
<p>那APP收到推送后将如何处理呢？其实也很简单。</p>
<p>安卓端点击通知将会拉起相应配置的activity，在activity的onCreate或者onNewIntent方法里获取到intent，intent.getData获取到Uri,就可以提前里面的参宿parma1了。</p>
<p>iOS端用户点击通知后会打开APP，信鸽已经处理了是冷启动和后台再次唤醒进入APP的情况，都会统一回调到一个接口，在回调接口里获取到一个字典数据。在早期免费版信鸽里，配置发附加参数就在这个字典里。改成收费版后，他们把附加参数转成json字符串放入了一个叫custom的字段里存储。将custom里的josn字符串取出来，再解析成字典就，就可以获取里面的path和param1参数了。然后再根据path来跳转到相应的页面，不再累述。</p>
<h2>Flutter如何处理页面跳转</h2>
<p>Flutter跟原生页面不同，但是Flutter页面天生支持path跳转，因为它是基于路由的。
Flutter APP接入信鸽跟原生APP是一样的，问题就在怎么将path传递到Flutter。这很简单，通过EventChannel。</p>
<p>Flutter APP的iOS端几乎和原生一样，变了的是，将path和param1参数通过event channel传递到Flutter层。</p>
<p>但是安卓端就稍微变了下。安卓原生APP有很多activity，每个activity都配置一个独立的path。到了Flutter APP只需一个MainActivity就可以了。</p>
<p>安卓的配置就变成了</p>
<div class="highlight"><pre><span></span>myscheme://myhost/main?path=page2&amp;param1=xx
</pre></div>


<p>这里myscheme://myhost/main就是不需要变的了（除非你还有的activity存在），要跳转的页面通过path参数来决定。native端MainActivity收到通知后需要将path等参宿传递到Flutter层</p>
<p>native端需要注意点：
这里需要特别注意当native端收到推送通知回调时，Flutter的event channel可能没有准备好，需要先将数据用一个变量存起来，等event channel准备好之后，再传递到Flutter，然后将数据清除。</p>
<p>这里特别说明一下，两端都是给Flutter层传递一个map数据：</p>
<div class="highlight"><pre><span></span>{path:page2,param1:xxx}
</pre></div>


<h3>Flutter层处理</h3>
<p>Flutter层处理也有一定技巧。在main函数执行的之后，就要开始注册监听event channel。
当event channel收到数据通知的时候，拿到数据map。然后用map里的path来做跳转。</p>
<div class="highlight"><pre><span></span><span class="o">//</span><span class="err">接收</span><span class="nt">native</span><span class="err">传递来的参数</span><span class="nt">obj</span>
  <span class="nt">void</span> <span class="nt">_onReceivePush</span><span class="o">(</span><span class="nt">Object</span> <span class="nt">obj</span><span class="o">)</span> <span class="p">{</span>
    <span class="err">WGLog.log(&#39;</span><span class="n">_onReceivePush</span><span class="p">:</span> <span class="err">$</span><span class="n">obj</span><span class="s1">&#39;);</span>
<span class="s1">    if (obj != null &amp;&amp; obj is Map) {</span>
<span class="s1">      Map&lt;String, dynamic&gt; pushData = Map&lt;String, dynamic&gt;.from(obj);</span>
<span class="s1">      String path = pushData</span><span class="cp">[</span><span class="s1">&#39;path&#39;</span><span class="cp">]</span><span class="s1">;</span>
<span class="s1">      if (path != null &amp;&amp; path.length &gt; 0) {</span>
<span class="s1">        if (!path.startsWith(&#39;</span><span class="o">/</span><span class="s1">&#39;)) {</span>
<span class="s1">          path = &#39;</span><span class="o">/</span><span class="err">&#39;</span> <span class="o">+</span> <span class="n">path</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nt">if</span> <span class="o">(</span><span class="nt">UserManager</span><span class="p">.</span><span class="nc">instance</span><span class="p">.</span><span class="nc">isLogin</span><span class="o">())</span> <span class="p">{</span>
          <span class="err">_handlePush(path,</span> <span class="err">pushData)</span><span class="p">;</span>
        <span class="p">}</span> <span class="nt">else</span> <span class="p">{</span><span class="err">//未登录的情况，先缓存数据登录后再使用</span>
          <span class="err">gPushData</span> <span class="err">=</span> <span class="err">obj</span><span class="p">;</span>
          <span class="err">WGToast.showToast(&quot;请先登录&quot;)</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="err">}</span> <span class="nt">else</span> <span class="p">{</span>
        <span class="err">WGLog.log(&quot;path</span> <span class="err">$path</span> <span class="err">error&quot;)</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="err">}</span>
  <span class="err">}</span>

  <span class="nt">void</span> <span class="nt">_handlePush</span><span class="o">(</span><span class="nt">String</span> <span class="nt">path</span><span class="o">,</span> <span class="nt">Map</span><span class="o">&lt;</span><span class="nt">String</span><span class="o">,</span> <span class="nt">dynamic</span><span class="o">&gt;</span> <span class="nt">args</span><span class="o">)</span> <span class="p">{</span>
    <span class="err">if</span> <span class="err">(path</span> <span class="err">==</span> <span class="err">&quot;/home&quot;</span> <span class="err">||</span> <span class="err">path</span> <span class="err">==</span> <span class="err">&quot;/main&quot;)</span> <span class="err">{</span>
      <span class="err">//首页</span>
    <span class="p">}</span> <span class="nt">else</span> <span class="p">{</span>
      <span class="err">Navigator.pushNamed(context,</span> <span class="err">path,</span> <span class="n">arguments</span><span class="p">:</span> <span class="n">args</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="err">}</span>
</pre></div>


<p>最重要的是 <strong>Navigator.pushNamed(context, path, arguments: args)</strong>这句代码。这args就是从native层传过来的map，里面可能包含要跳转页面的参数。</p>
<p>因为Flutter是基于路由的，所以路由注册很重要，还有相关页面如何获取或者处理传递过来的参数呢？
在MaterialApp的构造函数里有几个很重要的参数，routes，onGenerateRoute，onUnknownRoute。我们主要设置这几个参数来管理整个Flutter页面的路由。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">MyApp</span> <span class="kr">extends</span> <span class="nx">StatelessWidget</span> <span class="p">{</span>
  <span class="c1">// This widget is the root of your application.</span>
  <span class="kd">@override</span>
  <span class="nx">Widget</span> <span class="nx">build</span><span class="p">(</span><span class="nx">BuildContext</span> <span class="nx">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">MaterialApp</span><span class="p">(</span>
      <span class="nx">title</span><span class="o">:</span> <span class="s1">&#39;xxxx&#39;</span><span class="p">,</span>
       <span class="c1">//注册页面</span>
      <span class="nx">routes</span>: <span class="kt">AppRouter.routes</span><span class="p">,</span>
      <span class="nx">onGenerateRoute</span>: <span class="kt">AppRouter.generateRoute</span><span class="p">,</span>
      <span class="nx">onUnknownRoute</span>: <span class="kt">AppRouter.unknownRoute</span><span class="p">,</span>
      <span class="nx">home</span>: <span class="kt">MainPage</span><span class="p">(</span><span class="nx">title</span><span class="o">:</span> <span class="s1">&#39;xxx&#39;</span><span class="p">),</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>routes表示注册的路由表。当Navigator push一个命名路由的时候，会先到这个路由表里找对应path的路由，如果表里没有，就会进入onGenerateRoute，你可以在这里即时生成路由页面来处理，也可以不处理。如果onGenerateRoute没有处理，就会进入onUnknownRoute定义的路由页面。</p>
<p>我是这样配置的：
不需要额外参数的页面，直接注册在routes路由表里，需要传递额外参数才能打开的页面，放到onGenerateRoute动态生成（因为这里可以直接获取到外部传入的args），最后准备一个UnknownPage.而且这个UnknownPage很重要。设想你的APP已经发布了1.0，2.0，3.0版本。现在向全部用户发送推送消息，这个消息对应的页面是2.0版本才加入的，那么还在用1.0版本的用户收到这个通知后会怎么样。他会进入这个UnknownPage，你可以在这个页面提示他的APP版本太低，给个升级按钮，点击后可以跳转到商店去升级APP。</p>
<p>我把路由处理逻辑都放在一个这门的类来处理AppRouter。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">AppRouter</span> <span class="p">{</span>

  <span class="c1">///注册路由。routes比generateRoute的优先级高，先在routes找，找不到再到generateRoute找，最后找不到的话就进入unknownRoute</span>
  <span class="c1">///</span>
  <span class="kr">static</span> <span class="kr">final</span> <span class="nx">Map</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nx">WidgetBuilder</span><span class="o">&gt;</span> <span class="nx">routes</span> <span class="o">=</span> <span class="p">{</span>

    <span class="s1">&#39;/home&#39;</span><span class="o">:</span> <span class="p">(</span><span class="nx">BuildContext</span> <span class="nx">context</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">HomePage</span><span class="p">(),</span>
    <span class="s1">&#39;/bindSuc&#39;</span><span class="o">:</span> <span class="p">(</span><span class="nx">BuildContext</span> <span class="nx">context</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">BindSucPage</span><span class="p">(),</span>
    <span class="s1">&#39;/orderList&#39;</span><span class="o">:</span> <span class="p">(</span><span class="nx">BuildContext</span> <span class="nx">context</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">OrderListPage</span><span class="p">(),</span><span class="c1">// 我的订单列表</span>
 <span class="p">};</span>

  <span class="c1">//要注意页面参数的配置</span>
  <span class="kr">static</span> <span class="kr">final</span> <span class="nx">RouteFactory</span> <span class="nx">generateRoute</span> <span class="o">=</span> <span class="p">(</span><span class="nx">settings</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">WGLog</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;settings ${settings.toString()} &quot;</span><span class="p">);</span>
    <span class="nx">Map</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nx">dynamic</span><span class="o">&gt;</span> <span class="nx">params</span> <span class="o">=</span> <span class="nx">settings</span><span class="p">.</span><span class="nx">arguments</span> <span class="kr">as</span> <span class="nx">Map</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nx">dynamic</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">settings</span><span class="p">.</span><span class="nx">name</span> <span class="o">==</span> <span class="s1">&#39;/project&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nb">String</span> <span class="nx">pid</span> <span class="o">=</span> <span class="nx">params</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">pid</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">project</span> <span class="o">=</span> <span class="nx">HomeProject</span><span class="p">(</span><span class="nx">id</span>: <span class="kt">pid</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">MaterialPageRoute</span><span class="p">(</span>
            <span class="nx">builder</span><span class="o">:</span> <span class="p">(</span><span class="nx">ctx</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">ProjectDetailPage</span><span class="p">(</span><span class="nx">project</span>: <span class="kt">project</span><span class="p">,);</span>
            <span class="p">}</span>
        <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">settings</span><span class="p">.</span><span class="nx">name</span> <span class="o">==</span> <span class="s1">&#39;/applyDetail&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nb">String</span> <span class="nx">_id</span> <span class="o">=</span> <span class="nx">params</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">_id</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">model</span> <span class="o">=</span> <span class="nx">ApplyInfoModel</span><span class="p">(</span><span class="nx">apply_id</span>: <span class="kt">_id</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">MaterialPageRoute</span><span class="p">(</span>
            <span class="nx">builder</span><span class="o">:</span> <span class="p">(</span><span class="nx">ctx</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="nx">ApplyOrderDetailPage</span><span class="p">(</span><span class="nx">model</span>: <span class="kt">model</span><span class="p">,);</span>
            <span class="p">}</span>
        <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//....</span>

    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">/// 未知路由页面。一般是APP版本太低，推送过来的页面未定义</span>
  <span class="kr">static</span> <span class="kr">final</span> <span class="nx">RouteFactory</span> <span class="nx">unknownRoute</span> <span class="o">=</span> <span class="p">(</span><span class="nx">settings</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">MaterialPageRoute</span><span class="p">(</span>
        <span class="nx">builder</span><span class="o">:</span> <span class="p">(</span><span class="nx">ctx</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">UnknownPage</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></div>


<p>我认为generateRoute里的处理非常奇妙。设想有一个页面是一定要传一个id才可以正常浏览的。一般我们都会把这个页面的构造函数定义一个参数，由外部初始化的时候传入。如果将这个页面也支持注册到路由表routes里，那么你要获取传递过去的参数就有点麻烦了。你可能需要在该页面里面通过 <strong>var args=ModalRoute.of(context).settings.arguments</strong>方式来获取。这样不直观。</p>
<p>所以我认为这样处理Flutter的跳转是比较完美的方式。</p><p class="subheader">Category: <a href="https://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="https://szuwest.github.io/tag/flutter-tui-song-tong-zhi-xin-ge.html">Flutter 推送通知 信鸽 </a>
</p>



<p><a href="https://szuwest.github.io/flutter-appjia-ru-xin-ge-tui-song-tong-zhi-fang-an.html#disqus_thread">comments</a></p>            </article>


                <hr  class="gradient"/>


        


            <article>
                <a href="https://szuwest.github.io/yi-dong-duan-wen-dang-bian-yuan-jian-ce-aifang-an.html"><h3 class="article-title">移动端文档边缘检测AI方案</h3></a>
<h6 class="subheader" title="2020-11-27T00:00:00">2020-11-27
</h6>


<h1>移动端文档边缘检测AI方案</h1>
<h3>需求</h3>
<p>先说一下我们的需求：
我们需要用户拿手机扫描自己的体检单，然后我们识别体检单的内容，结构化数据后存起来用。
这里面解决方案一般都是手机客户端拍一张照片上传到服务器识别。而这张照片的好处直接影响了服务器的识别准确率。如果照片里有掺杂这别的内容就更不好了，最好照片里只有文档内容。这里就使用到了边缘检测技术。</p>
<h3>传统的边缘检测技术</h3>
<p>在传统的边缘检测方案中，大部分都是采用OpenCV里的边缘检测算法。OpenCV库在图像处理和识别方面真是鼎鼎大名，运用十分广泛。OpenCV库里的用到的叫cany和findContours算法，而且cany还有好几个版本。但是这个算法也不完美，很容易识别错，因为现实的场景也很复杂。</p>
<h3>HED算法方案</h3>
<p>现在哪里都流行用AI算法来优化。我在网上找到了fengjian大神的文章。原来我很早的时候就看到他写的<a href="http://fengjian0106.github.io/2017/05/08/Document-Scanning-With-TensorFlow-And-OpenCV/">这篇</a>文章。然后就按照他的方案来开干。我运行了他的demo，大致能得到满意的效果。但是他的文章很旧了，用到的TensorFlow还是很老版本，而且只开源了iOS版本。</p>
<p>经过我们的摸索，还有参考了别的一些demo，我终于把它移植到了TensorFlowLite，而且我还做了安卓的版本。这样两端的解决方案一致，可以运用到正式项目中。</p>
<p>当然，我们自己也做了很多优化，还有自己重新收集了一些我们场景的照片来训练新的模型。最终达到了不错的效果。</p>
<p>我把最初移植做的demo放到github上，给有需要的人参考。这里最大优势就是安卓和iOS的方案都有。</p>
<p><a href="https://github.com/szuwest/doc_detect_android">安卓版本</a></p>
<p><a href="https://github.com/szuwest/doc_detect_ios">iOS版本</a></p>
<hr />
<p>如果你觉得这篇文章有用，请打赏小钱喝杯咖啡 ...</p><p class="subheader">Category: <a href="https://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="https://szuwest.github.io/tag/bian-yuan-jian-ce-hed-opencv-tensorflowlite.html">边缘检测 HED OpenCV TensorFlowLite </a>
</p>



<p><a href="https://szuwest.github.io/yi-dong-duan-wen-dang-bian-yuan-jian-ce-aifang-an.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="https://szuwest.github.io/yi-dong-duan-wen-dang-bian-yuan-jian-ce-aifang-an.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="https://szuwest.github.io/apptui-song-he-apphuan-qi-ji-zhu-fang-an-tan-tao.html"><h3 class="article-title">APP推送和APP换起技术方案探讨</h3></a>
<h6 class="subheader" title="2020-08-04T00:00:00">2020-08-04
</h6>


<h1>APP推送和APP换起技术方案探讨</h1>
<h3>目标：</h3>
<p>尽量将APP两端设计成统一的方案，减少服务器适配工作量，最好可扩展，能复用。</p>
<h3>方案说明：</h3>
<p>我们知道APP推送目的是将对用户有用的信息，主动推给APP，作为通知信息展示，用户通过点击通知进入APP相关页面。</p>
<p>这里只要涉及服务器端和APP端两个技术点：服务器推送什么样的信息过来，APP这边如何解析接收到的信息，打开相应的界面和解析数据。</p>
<p>服务器只有一个，所以尽量让服务器发送给两端的数据较为一致，这需要一开始就应该想好整个系统的设计方案。</p>
<p>安卓和iOS是两个完全不同的平台，相关技术栈也不一样。不过基本都要依赖厂商的通讯通道来个APP发通知：苹果有自己的APN通道，Google也有自己的通道，当然在中国，各个厂商有自己的通道。有很多第三方SDK都整合多家厂商的通道。我们使用了信鸽（腾讯云移动推送）的SDK。之所以选他家，主要是他们集成了主流的厂商，文档也还可以（以前他们有免费版）。</p>
<p>为了能拉起APP不同的界面，我们需要定义一套规则。iOS的方案比较固定，只能通过json参数，这是它系统框架决定的。而安卓就不太一样，不同的厂商支持不同的方式，APP存活状态和未启动状态也不太一样。不过有一个方案是所有情形都适用的：就是通过定义Activity的scheme方式。</p>
<p>scheme方式是一种URI，我们经常用的URL地址也是一种URI。URI在iOS或者安卓都经常使用来拉起页面。例如我们的APP主页可以定义URI为: wegene://com.wegene ...</p><p class="subheader">Category: <a href="https://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="https://szuwest.github.io/tag/tui-song-huan-qi-la-qi.html">推送 唤起 拉起 </a>
</p>



<p><a href="https://szuwest.github.io/apptui-song-he-apphuan-qi-ji-zhu-fang-an-tan-tao.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="https://szuwest.github.io/apptui-song-he-apphuan-qi-ji-zhu-fang-an-tan-tao.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="https://szuwest.github.io/shen-du-xue-xi-ru-men-du-hou-gan.html"><h3 class="article-title">《深度学习入门》读后感</h3></a>
<h6 class="subheader" title="2020-05-05T00:00:00">2020-05-05
</h6>


<h1>《深度学习入门：基于Python的理论与实现》读后感</h1>
<p>最近因为做一个功能要用到深度学习相关知识和TensorFlowLite，我决定认真的学一下深度学习的知识。以前总觉得AI太高大上，怕自己看不懂。但是这次做这个功能让我意识到，如果自己再不学习，过几年可能就太晚了。我估计三五年之后，AI会渗透到各行各业，连APP开发也需要掌握一些深度学习的知识。</p>
<p>先说一下我们APP做的这个功能：用相机扫描检验单（体检单），将检验单截图上传到服务器，服务器进行OCR识别，并将数据结构化，用于生成用户的基因报告。这里涉及到APP开发的部分是将相机中的检验单检测并裁剪出来，上传到服务器识别。这里识别和裁剪部分很重要。将检验单准确的裁剪出来，可以提升OCR准确率。如果随意拍了一张图片，除了检验单部分，可能还包含了其他杂乱的背景，甚至其他不相关的文字内容。所以只将检验单部分裁剪出来是很重要的。</p>
<p>如果采用传统的OpenCV边缘检测方法来在图片中来找检验单，效果不尽人意。但是如果采用深度学习的方式来找检验单，那就可以得到很好的效果。当然这也是我们从fengjian大神博客学到的。我们采用他的方法，自己准备了一批数据训练，得到一个模型。而我们APP的任务就是在手机上采用TensorFlowLite运行我们的模型来推断得到相关结果。</p>
<p>因为做这个功能，我了解了下TensorFlowlite，但是我们深度学习却是了解不多。所以我决定找本书来学习一下。网上查了下，《深度学习入门：基于Python的理论与实现》这本书挺受好评，问了下我同事，他也看过这书，说写得不错 ...</p><p class="subheader">Category: <a href="https://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="https://szuwest.github.io/tag/shen-du-xue-xi-ren-gong-zhi-neng-du-hou-gan.html">深度学习 人工智能 读后感 </a>
</p>



<p><a href="https://szuwest.github.io/shen-du-xue-xi-ru-men-du-hou-gan.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="https://szuwest.github.io/shen-du-xue-xi-ru-men-du-hou-gan.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="https://szuwest.github.io/tan-tao-cong-h5ye-mian-la-qi-appde-ji-zhu-fang-an-he-wen-ti.html"><h3 class="article-title">探讨从H5页面拉起APP的技术方案和问题</h3></a>
<h6 class="subheader" title="2020-03-07T00:00:00">2020-03-07
</h6>


<h1>探讨从H5页面拉起APP的技术方案和问题</h1>
<p>从H5页面里拉起或叫唤起APP（APP需已经安装在手机上），有两种技术方案，一种通过HTTP链接（iOS叫 Universal Link，安卓叫APP Links技术）拉起技术，一种是通过自定义scheme拉起技术（也有叫深度链接deeplink的）。这两个技术适用不同的场景，也有不同的局限性。</p>
<h2>一、通过HTTP链接拉起</h2>
<p>要想通过HTTP(s)链接直接拉起APP，需要APP本身做一些配置和写一些代码实现，还需要在你网站服务器配置相关的json文件。例如配置服务器host，能打开页面的path等。有些了这些配置，苹果服务器或者谷歌的服务器验证了这些配置，就可以通过相关的HTTP链接来打开APP了</p>
<p>这里不管是iOS叫 Universal Link，还是安卓的APP Links，他们的技术方案是基本一样的，只是不同的平台稍微有些不一样的而已。基本规则是：</p>
<ul>
<li>先按照要求生成一个配置文件，json格式的，里面包括了一些必要的信息，例如安卓的包名，apk签名等，iOS的appID,匹配URL的path</li>
<li>将配置文件放到你的网站根目录下的.wellknown目录下，让苹果或谷歌的服务器能从这里下载这个配置文件。这个文件是关键，因为苹果或谷歌要从你网站里拉取到这个配置文件。由于你的网站只有你自己有权限上传配置文件，从而保证了安全性。</li>
<li>在你的APP里配置相关网站host ...</li></ul><p class="subheader">Category: <a href="https://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="https://szuwest.github.io/tag/app.html">APP </a>
</p>



<p><a href="https://szuwest.github.io/tan-tao-cong-h5ye-mian-la-qi-appde-ji-zhu-fang-an-he-wen-ti.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="https://szuwest.github.io/tan-tao-cong-h5ye-mian-la-qi-appde-ji-zhu-fang-an-he-wen-ti.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="https://szuwest.github.io/aopzai-yi-dong-kai-fa-zhong-de-ying-yong.html"><h3 class="article-title">AOP在移动开发中的应用</h3></a>
<h6 class="subheader" title="2020-01-21T00:00:00">2020-01-21
</h6>


<h1>AOP在移动开发中的应用</h1>
<p>下面是我在我们团队上的技术分享内容，从PPT里摘抄出来的，所有很多都是个提纲摘要</p>
<h2>AOP简介</h2>
<ul>
<li><strong>AOP，Aspect Oriented Programming，面向切面编程</strong></li>
<li>面向切面编程是一种通过横切关注点（Cross-cutting Concerns）分离来增强代码模块性的方法，它能够在不修改业务主体代码的情况下，对它添加额外的行为。</li>
<li>是对OOP的一种补充,是一种解耦的重要手段</li>
</ul>
<h3>AOP常用概念</h3>
<ul>
<li>Join point：程序执行期间的一个点,表示方法的执行</li>
<li>Pointcut: 切入点实际上也是从所有的连接点(Join point)挑选自己感兴趣的连接点的过程</li>
<li>Aspect: 程序横向切割成若干的面，即Aspect.每个面被称为切面</li>
<li>Advice: 某个特定连接点的某个方面采取的行动。不同类型的建议包括“周围(Around)”，“之前(Before)”和“之后(After)”建议</li>
</ul>
<h2>AOP实现原理</h2>
<ul>
<li>
<p>编译期间的静态织入，又称为编译时增强</p>
</li>
<li>
<p>运行期间的动态代理，又称为运行时增强</p>
</li>
</ul>
<h3>运行时AOP</h3>
<ul>
<li>程序运行时 ...</li></ul><p class="subheader">Category: <a href="https://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="https://szuwest.github.io/tag/aop-yi-dong-kai-fa.html">AOP 移动开发 </a>
</p>



<p><a href="https://szuwest.github.io/aopzai-yi-dong-kai-fa-zhong-de-ying-yong.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="https://szuwest.github.io/aopzai-yi-dong-kai-fa-zhong-de-ying-yong.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="https://szuwest.github.io/ji-yi-ci-webviewtian-keng-guo-cheng-you-huan-xing-fu-yin-fa-de-xie-an.html"><h3 class="article-title">记一次WebView填坑过程--由换行符引发的血案</h3></a>
<h6 class="subheader" title="2019-07-27T00:00:00">2019-07-27
</h6>


<h1>记一次WebView填坑过程--由换行符引发的血案</h1>
<p>最近使用WebView掉坑了，然后艰难爬坑经历感触很深，写出来大家借鉴一下。</p>
<h3>需求</h3>
<p>我们有个网页需要用到很多js库，这些库比较大，而且基本上是不变的。为了提高性能，将这些网页和JS库放到本地，进行加载。变的数据从服务器获取，然后跟本地的HTML组装后显示。这种需求还是挺普遍的。</p>
<h3>实现方式</h3>
<p>由web的同事调试好HTML文件，他们把所有的HTML，js,css,image和资源一起打包给我们
我们把这些资源放到assets目录下（也可以专门在assets再建一个子目录来放）</p>
<p>采用Android自带的WebView来加载和显示这些网页。有两个方法<strong>loadUrl</strong>和<strong>loadDataWithBaseUrl</strong>方法。</p>
<blockquote>
<p>1.loadUrl("file:///android_asset/xxxxxx.html")这种方式适合HTML不需要改变的情况，直接加载展示，省时省力</p>
<p>2.loadDataWithBaseUrl方式需要先把HTML内容现在到内存，然后再展示。这种方式可以随意修改HTML里的内容，修改好再交由WebView展示，灵活性强。</p>
</blockquote>
<h3>遇到的坑</h3>
<p>测试的时候，我们遇到同一个HTML文件，通过loadUrl方式加载展示，没有任何问题。但是通过loadDataWithBaseUrl加载展示，HTML的内容死活展示不出来 ...</p><p class="subheader">Category: <a href="https://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="https://szuwest.github.io/tag/androidkai-fa-webview-javascript.html">Android开发 WebView JavaScript </a>
</p>



<p><a href="https://szuwest.github.io/ji-yi-ci-webviewtian-keng-guo-cheng-you-huan-xing-fu-yin-fa-de-xie-an.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="https://szuwest.github.io/ji-yi-ci-webviewtian-keng-guo-cheng-you-huan-xing-fu-yin-fa-de-xie-an.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="https://szuwest.github.io/ru-he-xie-chu-bu-tai-pi-de-dai-ma.html"><h3 class="article-title">如何写出不太坏的代码</h3></a>
<h6 class="subheader" title="2019-02-28T00:00:00">2019-02-28
</h6>


<h2>如何写出不太坏的代码</h2>
<p>本来想把标题定为“如何写出好代码”的，但是转念一想，觉得自己没那么牛逼，就改成了不太坏的代码。只要不要写出太糟糕的代码，不就是好代码了吗？</p>
<p>以下只是个人的一些总结，如有异议，请出门右转。</p>
<h3>1.注重命名</h3>
<p>包括文件名，变量名，方法名。一般变量名以功能来命名，看它的名字就能知道它的用途是什么
遵循一些命名规范。Java中成员变量名一般以m开头，而OC中的成员变量一般以_开头</p>
<h3>2.遵循低耦合，高内聚的原则编写代码</h3>
<p>具体表现遵循分层分模块原则，底层模块不能依赖上层模块，逻辑层不依赖界面，绝不要把逻辑层代码和界面代码混在一起</p>
<h3>3.针对接口编程，而不是实现编程</h3>
<p>当一个类要暴露一些方法给外部调用或者通信时，先定义好接口。接口定义应该简单明了，不容易引起歧义，接口尽量少。最后才考虑内部实现，而且尽量不暴露给外部，尽量不需要外部知道内部是如何实现的</p>
<h3>4.一个类的代码量尽量不要太大，一个方法只做一件事情</h3>
<p>一个类（或者一个方法）的代码越多，出错的概率越大。一个类三到5百行代码最佳。如果一个类的代码太多，就要考虑这个类是不是做的东西太多了 ...</p><p class="subheader">Category: <a href="https://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="https://szuwest.github.io/tag/ioskai-fa-androidkai-fa.html">iOS开发 Android开发 </a>
</p>



<p><a href="https://szuwest.github.io/ru-he-xie-chu-bu-tai-pi-de-dai-ma.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="https://szuwest.github.io/ru-he-xie-chu-bu-tai-pi-de-dai-ma.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="https://szuwest.github.io/ioskai-fa-ru-he-zuo-wai-bu-ce-shi.html"><h3 class="article-title">iOS开发如何做外部测试</h3></a>
<h6 class="subheader" title="2019-01-05T00:00:00">2019-01-05
</h6>


<h2>iOS开发如何做外部测试</h2>
<p>我们做APP开发的，开发出来的APP还未上线，又要想给别人用一下，该怎么做？实际上这是我们每个做APP开发的人都会遇到的，但是并不是每个人都清楚怎么做，有哪些方式。今天我们就来讲一讲。</p>
<p>在将iOS的APP如何给别人使用和测试前，先说一下安卓APP开发是怎么做的。安卓端是很简单的，你只要先生成一个证书文件keystone，然后用这个文件给apk签名，就可以将apk发给任意一个人安装使用了。这很简单，也很方便。可是iOS的就没那么容易了。我们还是从最简单的开发人员如何用真机测试开始说起。</p>
<h3>真机调试</h3>
<p>我们有了一个想法，并开始写代码，模拟器调试很方便，要在iPhone上看效果怎么办了。你直接将iPhone连上电脑是不行的。现在的情况至少你需要一个Apple ID，在Xcode上登录你的账号，在调试前Xcode会自动帮你初始化一些东西，然后就可以将APP安装到你的iPhone上了。在以前，你这个AppleID不能是普通的账号，必须是付了前的开发者账号才行。现在苹果放宽限制了。</p>
<p>这种方式的做法是你的手机必须连上你的电脑，在Xcode上选择你的iPhone来调试，Xcode会自动帮你注册设备的UDID。如果你没办法把iPhone连接到电脑上呢？或者不方便把iPhone连接到电脑上，毕竟如果是老板的手机的话，不方便那种做的。那我们需要一种把安装包提供给别人安装，或者一个地址给别人安装的方式。</p>
<h3>adhoc 方式</h3>
<p>我们将项目archive后，在导出（现在Xcode叫distribution）的时候，有个选项是adhoc ...</p><p class="subheader">Category: <a href="https://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="https://szuwest.github.io/tag/ioskai-fa-betace-shi-testflight-gong-kai-lian-jie.html">iOS开发 beta测试 TestFlight 公开链接 </a>
</p>



<p><a href="https://szuwest.github.io/ioskai-fa-ru-he-zuo-wai-bu-ce-shi.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="https://szuwest.github.io/ioskai-fa-ru-he-zuo-wai-bu-ce-shi.html">Read More</a>
                <hr  class="gradient"/>
            </article>

        


            <article>
                <a href="https://szuwest.github.io/svgtu-pian-zai-yi-dong-duan-de-ying-yong-jie-jue-fang-an.html"><h3 class="article-title">SVG图片在移动端的应用解决方案</h3></a>
<h6 class="subheader" title="2018-11-03T00:00:00">2018-11-03
</h6>


<h2>SVG图片在移动端的应用解决方案</h2>
<p>近几年来SVG使用得越来越多，就连Android的官方库也加入VectorDrawable的支持。这个类就是用来支持向量图的。SVG图片在web端使用非常广泛，我第一次接触这个也是在做react-native的项目中使用的。当时我们要做一些动画，需要从一个形状变换成另一个形状，这种一般都是用矢量图来做的。当时设计师就给了我一些矢量图，于是我就开始研究这个东西。</p>
<p>在react-native中，有专门一个库叫<a href="https://github.com/react-native-community/react-native-svg">react-native-svg</a>来处理这个。不过当时要做两个SVG形状的动画变化，并不是任何一个形状都可以的，需要遵循一定的标准。设计师给我的两个SVG文件并不能转换。后来是我自己根据文件里的一些关键参数自己在代码里直接画出来后，再做转换动画。</p>
<p>最近我在做的native项目中，也遇到了要用SVG的图片。我们的项目里要从服务器下载SVG图片来展示。我们要实现的这些文件是需要服务器动态配置的，也就是说我们不能预先打包进我们的APP里。所以我们这里的要提供一个解决方案，跟图片JPG图片一样显示，缓存。</p>
<p>这个需求跟之前我遇到的那个需求是很不一样的，之前的是设计师已经定义好图片，我们工程师直接拿到文件在程序里展示，不需要考虑下载和缓存之类的。这种需求其实很简单，我们实际上大部分的需求就是这种需求，网上有很多库可以完成这种需求。把SVG图片跟JPG等普通图片一样使用，网上的方案还真不多，特别是iOS方面。。。。</p>
<p>要像普通图片一样使用，就要考虑下载，本地缓存，内存缓存。像这种需求，我们移动端都会使用专门的图片框架，像安卓端的glide，UIL等，iOS端的SDWebImage等。但是这种库它是默认都不会考虑SVG图片。但是我们最好还是像使用这种框架来处理SVG图片 ...</p><p class="subheader">Category: <a href="https://szuwest.github.io/category/ji-zhu.html">技术</a>

    Tagged: 
    <a href="https://szuwest.github.io/tag/suan-fa-svg-androidsvg-glide-macaw.html">算法 SVG androidsvg glide Macaw </a>
</p>



<p><a href="https://szuwest.github.io/svgtu-pian-zai-yi-dong-duan-de-ying-yong-jie-jue-fang-an.html#disqus_thread">comments</a></p>                <a class="button radius secondary small right" href="https://szuwest.github.io/svgtu-pian-zai-yi-dong-duan-de-ying-yong-jie-jue-fang-an.html">Read More</a>
                <hr  class="gradient"/>
            </article>

            <!-- /#posts-list -->
<div class="pagination-centered">
<h6 class="subheader">Page 1 of 3</h6>

<p>

        <a href="https://szuwest.github.io/category/ji-zhu2.html">Next &raquo;</a>
</p>
</div>

    </div>
    <!-- End Main Content -->

    <!-- Sidebar -->
    <aside class="large-3 columns">
        <h5 class="sidebar-title">Site</h5>
        <ul class="side-nav">
            <li><a href="https://szuwest.github.io/archives.html">Archives</a>
            <li><a href="https://szuwest.github.io/tags.html">Tags</a>


        </ul>

		
        <h5 class="sidebar-title">Categories</h5>
        <ul class="side-nav">
            <li><a href="https://szuwest.github.io/category/android.html">Android</a></li>
            <li><a href="https://szuwest.github.io/category/bian-cheng-jia-gou.html">编程架构</a></li>
            <li><a href="https://szuwest.github.io/category/chan-pin.html">产品</a></li>
            <li><a href="https://szuwest.github.io/category/ios.html">iOS</a></li>
            <li><a href="https://szuwest.github.io/category/ji-zhu.html">技术</a></li>
            <li><a href="https://szuwest.github.io/category/sheng-huo.html">生活</a></li>
            <li><a href="https://szuwest.github.io/category/suan-fa.html">算法</a></li>
            <li><a href="https://szuwest.github.io/category/zong-jie.html">总结</a></li>
   
        </ul>

        <h5 class="sidebar-title">Links</h5>
        <ul class="side-nav">
            <li><a href="https://szuwest.github.io/pages/about.html">About</a></li>
            <li><a href="https://szuwest.github.io/feeds/all.atom.xml">RSS</a></li>
        </ul>
		
        <h5 class="sidebar-title">Social</h5>
        <ul class="side-nav">
            <li><a href="https://github.com/szuwest">Github</a></li>
            <li><a href="https://www.facebook.com/profile.php?id=1084651913">Facebook</a></li>
            <li><a href="http://weibo.com/szuwest">微博</a></li>
        </ul>

    </aside> <!-- End Sidebar -->

</div> <!-- End Main Content and Sidebar -->


<!-- Footer -->
<footer class="row">
    <div class="large-12 columns">
        <hr />
        <div class="row">
            <div class="large-6 columns">
                <p>West's blog by West</p>
            </div>
            </div>
    </div>
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-55687145-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
</footer>